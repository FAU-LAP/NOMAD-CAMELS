# Patch generated by Pyment v0.3.3

--- a/.\nomad_camels\\loop_steps\read_channels.py
+++ b/.\nomad_camels\\loop_steps\read_channels.py
@@ -9,18 +9,7 @@
 
 
 class Read_Channels(Loop_Step):
-    """This step represents the bluesky plan stub `trigger_and_read`.
-
-    Attributes
-    ----------
-    read_all : bool
-        whether to simply read all available channels
-    channel_dict : dict
-        the dictionary of all channels and whether to read them. It also
-        provides "use set" for using the set-value without reading, but
-        that is not supported. The shape should look like:
-        {channel: {'read': True, 'use set': False}}
-    """
+    """This step represents the bluesky plan stub `trigger_and_read`."""
     def __init__(self, name='', parent_step=None, step_info=None, **kwargs):
         super().__init__(name, parent_step, step_info, **kwargs)
         self.step_type = 'Read Channels'
@@ -44,6 +33,7 @@
                     self.used_devices.append(device)
 
     def get_channels_set(self):
+        """ """
         chan_list = []
         if self.read_all:
             for channel in variables_handling.channels:
@@ -53,6 +43,17 @@
         return set(chan_list)
 
     def get_channels_string(self, tabs):
+        """
+
+        Parameters
+        ----------
+        tabs :
+            
+
+        Returns
+        -------
+
+        """
         channel_string = f'{tabs}channels_{self.variable_name()} = ['
         if not self.read_all and not self.channel_list:
             raise Exception(f'Trying to read no channel in {self.full_name}!')
@@ -66,12 +67,23 @@
         return channel_string
 
     def variable_name(self):
+        """ """
         return fit_variable_renaming.replace_name(self.name)
 
     def get_protocol_string(self, n_tabs=1):
         """In the protocol, at first a list `channels` is defined,
         including all the channels, that are selected to be read. Then
-        bps.trigger_and_read is called on these channels."""
+        bps.trigger_and_read is called on these channels.
+
+        Parameters
+        ----------
+        n_tabs :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         # checking compatibility with other readings
         chan_list = self.get_channels_set()
         if set(chan_list) in variables_handling.read_channel_sets:
@@ -94,11 +106,33 @@
         return protocol_string
 
     def get_protocol_short_string(self, n_tabs=0):
+        """
+
+        Parameters
+        ----------
+        n_tabs :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         short_string = super().get_protocol_short_string(n_tabs)
         short_string = f'{short_string[:-1]} - {self.channel_list}\n'
         return short_string
 
 def get_channel_string(channel):
+    """
+
+    Parameters
+    ----------
+    channel :
+        
+
+    Returns
+    -------
+
+    """
     name = variables_handling.channels[channel].name
     if '.' in name:
         dev, chan = name.split('.')
@@ -109,18 +143,28 @@
 
 
 class Read_Channels_Config(Loop_Step_Config):
+    """ """
     def __init__(self, loop_step:Read_Channels, parent=None):
         super().__init__(parent, loop_step)
         self.sub_widget = Read_Channels_Config_Sub(loop_step, self)
         self.layout().addWidget(self.sub_widget, 1, 0, 1, 5)
 
     def update_step_config(self):
+        """ """
         self.sub_widget.update_step_config()
 
 class Read_Channels_Config_Sub(Ui_read_channels_config, QWidget):
     """Config for the Read_Channels it provides a table of channels with
     a checkbox, whether to read them. Also there is a checkbox whether
-    to simply read all available channels."""
+    to simply read all available channels.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
     def __init__(self, loop_step:Read_Channels, parent=None):
         super().__init__(parent)
         self.setupUi(self)
@@ -147,6 +191,7 @@
         # self.tableWidget_channels.clicked.connect(self.table_check_changed)
 
     def use_trigger(self):
+        """ """
         self.loop_step.split_trigger = self.checkBox_split_trigger.isChecked()
 
     # def checkbox_toggle(self):
@@ -158,7 +203,15 @@
 
     def read_type_changed(self):
         """If the read-all checkbox is checked, disables the table, if
-        not, enables it."""
+        not, enables it.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         read_all = self.checkBox_read_all.isChecked()
         if hasattr(self, 'read_table'):
             self.read_table.setEnabled(not read_all)
@@ -181,6 +234,7 @@
         # self.build_channels_table()
 
     def update_step_config(self):
+        """ """
         self.loop_step.channel_list = self.read_table.get_info()['channel']
         # self.lineEdit_search.clear()
         # self.build_channels_table()
@@ -192,7 +246,17 @@
 
     def table_check_changed(self, pos):
         """If a checkbox inside the table is clicked, the value is
-        stored into the loopstep."""
+        stored into the loopstep.
+
+        Parameters
+        ----------
+        pos :
+            
+
+        Returns
+        -------
+
+        """
         r = pos.row()
         c = pos.column()
         if c == 0:
@@ -251,6 +315,7 @@
 
 
 class Trigger_Channels_Step(Loop_Step):
+    """ """
 
     def __init__(self, name='', parent_step=None, step_info=None, **kwargs):
         super().__init__(name, parent_step, step_info, **kwargs)
@@ -262,7 +327,17 @@
     def get_protocol_string(self, n_tabs=1):
         """In the protocol, at first a list `channels` is defined,
         including all the channels, that are selected to be read. Then
-        bps.trigger_and_read is called on these channels."""
+        bps.trigger_and_read is called on these channels.
+
+        Parameters
+        ----------
+        n_tabs :
+             (Default value = 1)
+
+        Returns
+        -------
+
+        """
         tabs = '\t' * n_tabs
         protocol_string = super().get_protocol_string(n_tabs)
         read_step = variables_handling.current_protocol.loop_step_dict[self.read_step]
@@ -273,6 +348,17 @@
         return protocol_string
 
     def get_protocol_short_string(self, n_tabs=0):
+        """
+
+        Parameters
+        ----------
+        n_tabs :
+             (Default value = 0)
+
+        Returns
+        -------
+
+        """
         short_string = super().get_protocol_short_string(n_tabs)
         read_step = variables_handling.current_protocol.loop_step_dict[self.read_step]
         short_string = f'{short_string[:-1]} - {read_step.channel_list}\n'
@@ -280,6 +366,7 @@
 
 
 class Trigger_Channels_Config(Loop_Step_Config):
+    """ """
     def __init__(self, loop_step:Trigger_Channels_Step, parent=None):
         super().__init__(parent, loop_step)
         label = QLabel('Corresponding Read-Step:')
@@ -293,5 +380,6 @@
         self.comboBox_read_step.addItems(triggerable)
 
     def update_step_config(self):
+        """ """
         self.loop_step.read_step = self.comboBox_read_step.currentText()
         super().update_step_config()
