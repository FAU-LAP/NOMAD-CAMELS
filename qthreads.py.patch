# Patch generated by Pyment v0.3.3

--- a/.\nomad_camels\\utility\qthreads.py
+++ b/.\nomad_camels\\utility\qthreads.py
@@ -18,7 +18,15 @@
 class Make_Ioc(QThread):
     """Called from the MainApp.
     It runs the steps from the make_ioc package to create a
-    fully operational IOC."""
+    fully operational IOC.
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+
+    """
     sig_step = Signal(int)
     info_step = Signal(str)
 
@@ -40,6 +48,7 @@
         self.device_data = device_data
 
     def run(self):
+        """ """
         self.sig_step.emit(0)
         info = make_ioc.clean_up_ioc(self.ioc_name)
         self.info_step.emit(info)
@@ -74,7 +83,15 @@
         """Runs the given `protocol` at `file_path`. If `sig_step` is
         provided, the stdout will be written there. If `info_step` is
         provided, it will update the completed-percentage with each starting
-        loopstep."""
+        loopstep.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         cmd = ['.desertenv/Scripts/pythonw', '-c', "from IPython import embed; embed()"]
         flags = 0
         if os.name == 'nt':
@@ -104,6 +121,19 @@
         self.sig_step.emit(100)
 
     def run_protocol(self, path, prot_time):
+        """
+
+        Parameters
+        ----------
+        path :
+            
+        prot_time :
+            
+
+        Returns
+        -------
+
+        """
         while not self.ready_to_run:
             time.sleep(0.1)
         name = os.path.basename(path)[:-3]
@@ -121,6 +151,7 @@
         # self.write_to_console(f'print(dat_{name})')
 
     def pause(self):
+        """ """
         # os.kill(self.p.pid, signal.SIGINT)
         # self.popen.stdin.write('print("test")\n'.encode())
         # self.popen.stdin.flush()
@@ -128,6 +159,7 @@
         self.paused = True
 
     def abort(self):
+        """ """
         if not self.paused:
             self.pause()
         msg = f'{self.current_protocol}_mod.RE.abort()'
@@ -136,10 +168,22 @@
         self.terminate()
 
     def resume(self):
+        """ """
         msg = f'{self.current_protocol}_mod.RE.resume()'
         self.write_to_console(msg)
 
     def write_to_console(self, msg):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+
+        Returns
+        -------
+
+        """
         if msg == 'exit()':
             raise Exception('Exiting the shell is not allowed!')
         if self.popen is not None:
@@ -171,7 +215,15 @@
         """Runs the given `protocol` at `file_path`. If `sig_step` is
         provided, the stdout will be written there. If `info_step` is
         provided, it will update the completed-percentage with each starting
-        loopstep."""
+        loopstep.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
         # self.counter = 0
         # self.total_time = prot_time
         dark = variables_handling.dark_mode
@@ -203,6 +255,19 @@
         # self.sig_step.emit(100)
 
     def run_protocol(self, path, prot_time):
+        """
+
+        Parameters
+        ----------
+        path :
+            
+        prot_time :
+            
+
+        Returns
+        -------
+
+        """
         while not self.ready_to_run:
             time.sleep(0.1)
         name = os.path.basename(path)[:-3]
@@ -220,6 +285,7 @@
         # self.write_to_console(f'print(dat_{name})')
 
     def pause(self):
+        """ """
         # os.kill(self.p.pid, signal.SIGINT)
         # self.popen.stdin.write('print("test")\n'.encode())
         # self.popen.stdin.flush()
@@ -227,6 +293,7 @@
         self.paused = True
 
     def abort(self):
+        """ """
         if not self.paused:
             self.pause()
         msg = f'{self.current_protocol}_mod.RE.abort()'
@@ -235,10 +302,22 @@
         self.terminate()
 
     def resume(self):
+        """ """
         msg = f'{self.current_protocol}_mod.RE.resume()'
         self.write_to_console(msg)
 
     def write_to_console(self, msg):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+
+        Returns
+        -------
+
+        """
         if msg == 'exit()':
             raise Exception('Exiting the shell is not allowed!')
         if self.popen is not None:
@@ -250,13 +329,15 @@
 
 
 class Run_IOC(QThread):
-    """
-    Runs the given IOC in the background.
+    """Runs the given IOC in the background.
 
     Parameters
     ----------
     ioc_name : str, optional
         The name of the IOC to run, by default 'Default'
+
+    Returns
+    -------
 
     Attributes
     ----------
@@ -279,6 +360,7 @@
         self.curr_last = -1
 
     def run(self):
+        """ """
         flags = 0
         if os.name == 'nt':
             flags = subprocess.CREATE_NO_WINDOW
@@ -297,6 +379,17 @@
         #     self.info_step.emit(text)
 
     def write_to_ioc(self, msg):
+        """
+
+        Parameters
+        ----------
+        msg :
+            
+
+        Returns
+        -------
+
+        """
         if 'exit' in msg:
             raise Exception('Please stop the IOC only using the button!\n(The command "exit" is not allowed!)')
         self.last_inputs.append(msg)
@@ -306,12 +399,14 @@
 
 
     def terminate(self) -> None:
+        """ """
         if self.popen is not None:
             self.popen.communicate(input=b'exit')
         super().terminate()
 
 
 class Manual_Device_Thread(QThread):
+    """ """
     def __init__(self, device, ophyd_class):
         super().__init__()
         if device.ioc_settings['use_local_ioc']:
@@ -325,6 +420,19 @@
         self.device.configure(device.get_config())
 
     def update_config_settings(self, config=None, settings=None):
+        """
+
+        Parameters
+        ----------
+        config :
+             (Default value = None)
+        settings :
+             (Default value = None)
+
+        Returns
+        -------
+
+        """
         config = config or {}
         settings = settings or {}
         self.device.configure(config)
